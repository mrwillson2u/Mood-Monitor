<!doctype html>
<html>
  <head>
    <title>Mood Graph</title>
    <!-- <link rel="stylesheet" type="text/css" href="style.css"> -->
    <script src="pixi/bin/pixi.js"></script>
    <style>
      body { font: 13px Helvetica, Arial; }

    </style>
  </head>
  <body>



    <!-- <script src="https://cdn.socket.io/socket.io-1.3.5.js"></script> -->
    <script src="/socket.io/socket.io.js"></script>

    <script src="http://code.jquery.com/jquery-1.11.1.js"></script>
    <!-- <script src="pixi.js"></script> -->

    <script>
      var socket = io();

      var renderer = new PIXI.autoDetectRenderer(window.innerWidth, 1000,{backgroundColor : 0xFFFFFF})
    	document.body.appendChild(renderer.view);

      var stage = new PIXI.Container(0xFFFFFF);
      var graph = new PIXI.Container(0xFF0000);
      stage.addChild(graph);

      var graphWidth = window.innerWidth;
      var graphHeight = 600;

      var graphBackground = new PIXI.Graphics()
      graphBackground.beginFill(0x000000);
      graphBackground.drawRect(0, 0, window.innerWidth, 600);

      graph.addChild(graphBackground);

      var graphics = new PIXI.Graphics()

      graph.addChild(graphics);

      var points = [];
      var pointSpacing = 50;

      graphBackground.height = 600;

      animate();

      function animate() {
        requestAnimationFrame( animate );
        renderer.render(stage);
      }

      socket.on('mood data', function(msg){
        // $('#messages').append($('<li>').text(msg));

        function normalizeForGraph(input) {
          return graphHeight - (input * graphHeight);
        }

        points.push([{value: msg.RAW_READING, normalized: normalizeForGraph(msg.RAW_READING/1024), color: 0xFF0000},
          {value: msg.RAW_READING, normalized: normalizeForGraph(msg.RAW_READING/1024), color: 0x0099CC},
          {value: msg.RAW_MOOD, normalized: normalizeForGraph(msg.RAW_MOOD), color: 0x33CC33},
          {value: msg.SMOOTH_MOOD, normalized: normalizeForGraph(msg.SMOOTH_MOOD), color: 0xFF9900},
          {value: msg.TOP_CAL, normalized: normalizeForGraph(msg.TOP_CAL), color: 0xFF33CC},
          {value: msg.BOT_CAL, normalized: normalizeForGraph(msg.BOT_CAL), color: 0xFF6699}]);

          // Add the text objects for all the data sets
          for(var i = 0; i < points[points.length-1].length; i++) {
            points[points.length-1][i].text = new PIXI.Text(points[points.length-1][i].value);
            points[points.length-1][i].text.style = {font: '15px Arial', fill: points[points.length-1][i].color};
            points[points.length-1][i].text.anchor.y = 0.5;
            points[points.length-1][i].text.x = renderer.width;
            points[points.length-1][i].text.rotation = 90 * Math.PI / 180;
            // console.log("Num: " + points[points.length-1][i].value + "width: " + ((i > 0) ? points[points.length-1][i-1].text.width : 10));
            points[points.length-1][i].text.y = ((i > 0) ? points[points.length-1][i-1].text.width + points[points.length-1][i-1].text.y + 10 : graphHeight + 10);
            // points[points.length-1][i].text.y = ((i+1) * 40) + 610;
            stage.addChild(points[points.length-1][i].text);
          }

        // console.log('length: ' + rawPoints.length + ' value: ')
        // normalize data Values

        graphics.clear();

        var pointScreenIndex = 0;
        if(points.length > renderer.width) {
          pointScreenIndex = points.length - renderer.width;
        }

        // Red, Blue, Green, Orange, Purple, pink
        // var colorArray = [0xFF0000, 0x0099CC, 0x33CC33, 0xFF9900, 0xFF33CC, 0xFF6699];

        for(var i = pointScreenIndex; i < points.length; i++) {

          for(var j = 0; j < points[i].length; j++) {
            graphics.beginFill(points[i][j].color);
            graphics.lineStyle(2, points[i][j].color);

            // Draw lines between points
            if(i > 0) {
              console.log("graph.height: " + graph.height);
              graphics.moveTo(renderer.width - ((points.length - (i-1)) * pointSpacing), points[i - 1][j].normalized);
              graphics.lineTo(renderer.width - ((points.length - i) * pointSpacing), points[i][j].normalized);

            }

            graphics.drawCircle(renderer.width - ((points.length - i) * pointSpacing), points[i][j].normalized, 2);

            // console.log("points[i][j]: ", points[i][j]);
            points[i][j].text.x = renderer.width - ((points.length - i) * pointSpacing);
            // text.y = ((j+1) * 50) + 600;

          }
        }
      });
    </script>

    <button id="save_button" type="button">Save Data</button>

  </body>
</html>
